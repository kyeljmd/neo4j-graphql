type BasicInfo {
  agentCode: ID!
  createdDate: Date
  effectiveDate: Date
  lastName: String
  nickName: String
  displayName: String
  companyName: String
  middleName: String
  birthDate: String
  titleCode: String
  birthPlace: String
  firstName: String
  number: String
  nationalityCode: String
  gender: String
  classificationCode: String
  profileType: String
  civilStatusCode: String
  profileTypeCode: String
  suffixCode: String
}

type Team {
  code: ID!
  createdDate: Date
  displayName: String
  teamTypeCode: String
  shortTeamName: String
  effectiveDate: Date
  statusCode: String
  members: [Team] @relation(name: "BRANCH_HAS_TEAM", direction: "OUT")
  advisors: [Advisor] @relation(name: "MEMBER_OF", direction: "OUT")
  entity: [Entity] @relation(name: "ENTITY_HAS_BRANCH", direction: "IN")
  contracts: [Contract] @relation(name: "IS_CONTRACT_ASSIGNED_TEAM", direction: "IN")
}


type TeamHierarchy{ 
  costCenterCode: String
  distributionChannelCode: String
  entityCode: String
  code: ID!
  displayName: String
  teamCode: String
  shortTeamName: String
  longTeamName: String
  createdDate: Date
  longTeamCode: String
  teamTypeCode: String
  effectiveDate: Date
  costCenterFlag: String
  statusCode: String
}

type Entity {
  code: ID!
  displayName: String
  entityName: String
  createdDate: Date
  effectiveDate: Date
  statusCode: String
  totalActiveAgency: Int @cypher(statement: "MATCH (a:Advisor)-[hc:HAS_CONTRACT]->(c:Contract)-[he:HAS_ENTITY]->(this) WHERE a.statusCode = 'A' and c.distributionChannelCode='CAN' RETURN count(distinct a)")
  totalActiveBroker: Int @cypher(statement: "MATCH (a:Advisor)-[hc:HAS_CONTRACT]->(c:Contract)-[he:HAS_ENTITY]->(this) WHERE a.statusCode = 'A' and c.distributionChannelCode='BRO' RETURN count(distinct a)")
  totalActive: Int @cypher(statement: "MATCH (a:Advisor)-[hc:HAS_CONTRACT]->(c:Contract)-[he:HAS_ENTITY]->(this) WHERE a.statusCode = 'A' RETURN count(distinct a)")
  activeCodedAdvisorsYearTodate: Int @cypher(statement: "MATCH (a:Advisor)-[:HAS_CONTRACT]->(c:Contract) MATCH (cop:CutOffParam {type: 'ACBON', status: 'C'}) WHERE c.entityCode = this.code and c.contractEffectiveDate.year <= cop.endDate.year RETURN count(distinct a)")
  activeCodedAdvisorsMonthToDate: Int @cypher(statement: "MATCH (a:Advisor)-[:HAS_CONTRACT]->(c:Contract) MATCH (cop:CutOffParam {type: 'ACBON', status:'C'}) WHERE a.statusCode='A' and c.entityCode = 'ENTITY_01' and c.contractEffectiveDate > cop.startDate and c.contractEffectiveDate <= cop.endDate RETURN count(distinct a)")
  cancelledCodedAdvisorsYearTodate: Int @cypher(statement: "MATCH (a:Advisor)-[:HAS_CONTRACT]->(c:Contract) MATCH (cop:CutOffParam {type: 'ACBON', status: 'C'}) WHERE a.statusCode='C' and c.entityCode = this.code and c.contractEffectiveDate.year <= cop.endDate.year RETURN count(distinct a)")
  cancelledCodedAdvisorsMonthToDate: Int @cypher(statement: "MATCH (a:Advisor)-[:HAS_CONTRACT]->(c:Contract) MATCH (cop:CutOffParam {type: 'ACBON', status:'C'}) WHERE a.statusCode='C' and c.entityCode = 'ENTITY_01' and c.contractEffectiveDate > cop.startDate and c.contractEffectiveDate <= cop.endDate RETURN count(distinct a)")
  vestedAdvisors:  Int @cypher(statement: "MATCH (a:Advisor)-[hc:HAS_CONTRACT]->(c:Contract)-[he:HAS_ENTITY]->(this) WHERE a.statusCode = 'V' RETURN count(distinct a)")
}

type Recruit {
  code: ID!
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
  info: [BasicInfo] @relation(name: "IS_BASIC_INFO_OF", direction: "IN")
  contactNumber: [ContactInfo] @relation(name: "HAS_MOBILE", direction: "OUT")
  email: [ContactInfo] @relation(name: "HAS_EMAIL", direction: "OUT")
  address: [AddressInfo] @relation(name: "LIVES_IN", direction: "OUT")
  entity: [Entity] @relation(name: "IS_RECRUIT_OF", direction: "OUT")
  recruitmentInfo: [Task] @relation(name: "IS_TASK_TO", direction: "IN")
}



type SpecialIDInfo {
  code: ID!
  createdDate: Date!
  agentCode: String
  displayName: String
  value: String
  effectiveDate: Date
  idTypeCode: String
  statusCode: String
}

type License {
  licenseRenewalDate: String
  entityCode: String
  code: ID!
  agentCode: String
  displayName: String
  licenseTypeCode: String
  licenseSurrenderDate: String
  provisionalAuthorityEffectiveDate: String
  licenseType: String
  licenseExpiryDate: Date
  createdDate: Date
  actualLicenseEffectiveDate: Date
  effectiveDate: Date
  remarks: String
  statusCode: String
}

type Override {
  entityCode: String
  code: String
  createdDate: Date
  agentCode: String
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type ContactInfo  {
  code: ID!
  createdDate: String
  contactTypeCode: String
  agentCode: String
  displayName: String
  contactType: String
  value: String
  effectiveDate: Date
  statusCode: String
}

type AddressInfo{
  addressType: String
  addressTypeCode: String
  agentCode: ID!
  cityCode: String
  code: String
  country: String
  countryCode: String
  createdDate: Date
  displayName: String
  effectiveDate: Date
  postalCode: String
  province:  String
  provinceCode: String
  statusCode: String
  streetAddress: String
}

type Address{
  addressTypeCode:  String
  streetAddress:  String
  cityCode: String
  provinceCode: String
  countryCode:  String
  postalCode: String
  mailingAddressFlag: String
}

type Workflow {
  name: String
  code: String
  tasks: [Task] @relation(name: "HAS_TASK", direction: "OUT")
}

type Advisor {
  code: ID!
  createdDate: Date
  effectiveDate: Date
  displayName: String
  classificationCode: String
  statusCode: String
  contracts: [Contract] @relation(name: "HAS_CONTRACT", direction: "OUT")
  info: BasicInfo @relation(name: "HAS_BASIC_PROFILE", direction: "OUT")
  manager: [Advisor] @cypher(statement: "MATCH (this)-[:HAS_ADVISOR_HIERARCHY]->(:AdvisorHierarchy)-[:REPORTS_TO]->(:AdvisorHierarchy)<-[HAS_ADVISOR_HIERARCHY]-(manager:Advisor) WHERE  this.code <> manager.code RETURN manager")
  manages: [Advisor]
  @cypher
  (statement: 
  "MATCH (a:AdvisorHierarchy)<-[r:REPORTS_TO]-(o:AdvisorHierarchy)-[r1:HAS_LEVEL]->(o1:AdvisorHierarchyLevel) MATCH (a1: Advisor) where a.agentCode=this.code AND o.agentCode=a1.code  RETURN distinct a1")
  entities: [Entity] @cypher(statement: "MATCH (this)-[rc:HAS_CONTRACT]->(n:AdvisorContract)-[r]->(v:Entity) RETURN v")
  ids: [SpecialIDInfo] @relation(name: "HAS_SPECIAL_ID_INFO", direction: "OUT")
  addresses: [AddressInfo] @relation(name: "HAS_ADDRESS_INFO", direction: "OUT")
  contactInfo:[ContactInfo] @relation(name: "HAS_CONTACT_INFO", direction: "OUT")
  licenses: [License] @relation(name: "HAS_LICENSE", direction: "OUT")
  disbursement: [Disbursement] @relation(name:"HAS_DISBURSEMENT", direction: "OUT")
  hierarchyUpwards: [HierarchyTree] @neo4j_ignore
  hierarchyDownwards: [HierarchyTree] @neo4j_ignore
}

type Task @additionalLabels(labels: ["Recruitment"]) {
  hash: ID!
  caption: String
  taskType: String
  updatedBy: String
  createdDate: String
  documents: String
  createdBy: String
  assignee: String
  updatedDate: String
  status: String
  toRecruit: [Recruit] @relation(name: "IS_TASK_TO_RECRUIT", direction: "OUT")
  workflow: [Workflow] @relation(name: "IS_TASK_OF_WORKFLOW", direction: "OUT")
}

type Contract {
  code: ID!
  classificationEffectiveDate: Date
  distributionChannelCode: String
  entityCode: String
  immediateManagerEffectiveDate: Date
  agentCode: String
  displayName: String
  unitEffectiveDate: Date
  classification: String
  contractEffectiveDate: Date
  classificationCode: String
  createdDate: Date
  distributionChannel: String
  effectiveDate: Date
  statusCode: String
  entities: [Entity] @relation(name: "HAS_ENTITY", direction: "OUT")
  branch: [Team] @relation(name:"HAS_TEAM", direction: "OUT")
  unit: [Team] @relation(name:"HAS_UNIT", direction: "OUT")
  manager: [Advisor] @cypher(statement: "MATCH(this)<-[:IS_HIERARCHY_IN_CONTRACT]-(o)<-[:HAS_ADVISOR_HIERARCHY]-(kl:Advisor) RETURN kl")
  advisors: [ContractAdvisor]
}

type AdvisorHierarchy{
  code: ID!
  entityCode: String
  immediateManager: String
  contractCode: String
  agentCode: String
}

type AdvisorHierarchyLevel {
  code: ID!
  entityCode: String
  level: String
  managerCode: String
  managerClassificationCode: String
  agentCode: String
}

type BankAccount {
 code: ID!
 bankAccountName: String
 createdDate: String
 agentCode: String
 displayName: String
 bankAccountNumber: String
 effectiveDate: Date 
 statusCode: String
}

type Bonus {
  entityCode: String
  code: ID!
  createdDate: Date
  agentCode: String
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type Classification {
  code: ID!
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type Commission {
  entityCode: String
  code: ID!
  createdDate: Date
  agentCode: String
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type Credit {
  entityCode: String
  code: ID!
  createdDate: Date
  agentCode: String
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type DistributionChannel {
  code: ID!
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type Employee {
  code: ID!
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type Disbursement {
  bankCode: String
  entityCode: String
  code: ID!
  createdDate: Date
  agentCode: String
  displayName: String
  disbursementMethodCode: String
  bankName: String
  accountNumber: String
  disbursementMethod: String
  effectiveDate: Date
  statusCode: String
}

type Payroll {
  entityCode: String  
  code: ID!
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
  agentCode: String
}

type Policy {
  code: String
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type Product {
  code: ID!
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
}

type Rate {
  code: ID!
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
  value: String
}

type Transaction {
  createdDate: Date
  displayName: String
  effectiveDate: Date
  statusCode: String
  amount: String
}


type Period {
  entityCode: String
  code: String
  startDate: Date
  cutoffDate: String
}

type Calendar {
  hash:ID!
  caption:String
  cutoffYear: String
  cutOffParams: [Calendar] @relation(name: "IS_REPORT_CUTOFFPARAMS_FOR", direction: "OUT")
}


type Report @additionalLabels(labels: ["RecruitmentTarget"]) {
  cutoffYear: String
  hash:ID!
  targetAdvisors: String
  targetEffectiveDate:String
  entity: [Entity] @relation(name: "IS_REPORT_RECRUITMENT_OF", direction: "OUT")
}

type Level {
  level: Int
}

type HierarchyTree {
  level: Level!
  advisor:Advisor!
}

type DistributionChannel{
  agency: String
  broker: String
  totalActive: String
}

# relationships
type ContractAdvisor @relation(name: "IS_CONTRACT_OF"){
    classificationCode:String 
    classificationEffectiveDate: Date
    advisorStatusCode:String
    advisorStatusEffectiveDate:String
    to: [Advisor]
    from: [Contract]
}

type CutOffParam {
  type: String
  startDate: Date
  endDate: Date
  status: String
  cutOffYear: Int
  cutOffMonth: Int
  weekendFlag: Int
  midMonthFlag: Int
  monthEndFlag: Int
  quarterEndFlag: Int
  midYear: Int 
  yearEnd: Int
}


type Query{
  distributionChannel:[DistributionChannel]
}

type Mutation {
  createAdvisorWithManager(lastName: String,
    nickName: String,
    companyName: String,
    birthDate: String,
    titleCode: String,
    birthPlace: String,
    firstName: String,
    number: String,
    nationalityCode: String,
    genderCode: String,
    classificationCode: String,
    civilStatusCode: String,
    profileTypeCode: String,
    middleName: String,
    effectiveDate: String,
    managerId: String,
    suffixCode: String):[Advisor]
  
  createAdvisorNoManager(lastName: String,
    nickName: String,
    companyName: String,
    birthDate: String,
    titleCode: String,
    birthPlace: String,
    firstName: String,
    number: String,
    nationalityCode: String,
    genderCode: String,
    classificationCode: String,
    civilStatusCode: String,
    profileTypeCode: String,
    middleName: String,
    effectiveDate: String,
    suffixCode: String):[Advisor] 
}
